# 智慧旅遊行程規劃系統 - 規劃邏輯完整文件

---

**文件版本 (Document Version):** `v1.0`  
**最後更新 (Last Updated):** `2025-09-30`  
**主要作者 (Lead Author):** `AI Assistant`  
**狀態 (Status):** `正式版 (Official)`

---

## 目錄

1. [系統概述](#1-系統概述)
2. [整體架構流程](#2-整體架構流程)
3. [對話式規劃流程](#3-對話式規劃流程)
4. [資訊收集與解析](#4-資訊收集與解析)
5. [地點檢索策略](#5-地點檢索策略)
6. [評分與排序邏輯](#6-評分與排序邏輯)
7. [核心規劃演算法](#7-核心規劃演算法)
8. [路徑優化機制](#8-路徑優化機制)
9. [住宿推薦邏輯](#9-住宿推薦邏輯)
10. [使用者回饋處理](#10-使用者回饋處理)
11. [錯誤處理與容錯](#11-錯誤處理與容錯)
12. [效能優化策略](#12-效能優化策略)

---

## 1. 系統概述

### 1.1 核心目標

智慧旅遊行程規劃系統旨在透過對話式 AI 互動，自動生成符合使用者需求的個性化旅遊行程。系統結合了以下關鍵技術：

- **LangGraph 狀態機**: 管理對話流程與規劃狀態
- **混合式檢索**: 結合結構化查詢與語義搜尋
- **貪婪演算法**: 快速生成可行行程
- **2-opt 優化**: 局部優化路徑以減少交通時間
- **OSRM 路網計算**: 精確計算景點間交通時間

### 1.2 核心概念

- **Story (使用者故事)**: 使用者的旅遊需求抽象化，包含天數、時間窗、偏好主題等
- **Place (景點)**: 旅遊目的地，包含地理位置、類別、營業時間、評分等屬性
- **Itinerary (行程)**: 完整的旅遊計畫，包含每日景點訪問順序與時間安排
- **Visit (訪問)**: 單一景點的訪問記錄，包含到達時間 (ETA)、離開時間 (ETD)、交通時間
- **Accommodation (住宿)**: 每日的住宿安排

---

## 2. 整體架構流程

### 2.1 系統架構圖

```
┌─────────────┐
│  使用者輸入  │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────────────────┐
│           LangGraph 對話式狀態機                      │
│                                                       │
│  ┌──────────────────────────────────────────────┐   │
│  │ 1. 對話記憶管理 (conversation_memory_manager) │   │
│  └────────────┬─────────────────────────────────┘   │
│               │                                       │
│               ▼                                       │
│  ┌──────────────────────────────────────────────┐   │
│  │ 2. 資訊收集 (info_collector)                  │   │
│  └────────────┬─────────────────────────────────┘   │
│               │                                       │
│               ▼                                       │
│         [資訊是否完整?]                               │
│               │                                       │
│       ┌───────┴────────┐                            │
│       NO               YES                           │
│       │                 │                            │
│       ▼                 ▼                            │
│   返回問題    ┌──────────────────────────────────┐  │
│              │ 3. 提取故事 (extract_story)       │  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
│                           ▼                         │
│              ┌──────────────────────────────────┐  │
│              │ 4. 結構化檢索 (retrieve_structured)│  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
│                           ▼                         │
│              ┌──────────────────────────────────┐  │
│              │ 5. 語義檢索 (retrieve_semantic)   │  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
│                           ▼                         │
│              ┌──────────────────────────────────┐  │
│              │ 6. 排序融合 (rank_and_merge)     │  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
│                           ▼                         │
│              ┌──────────────────────────────────┐  │
│              │ 7. 住宿檢索 (retrieve_accommodations)│  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
│                           ▼                         │
│              ┌──────────────────────────────────┐  │
│              │ 8. 行程規劃 (plan_itinerary)     │  │
│              └────────────┬─────────────────────┘  │
│                           │                         │
└───────────────────────────┼─────────────────────────┘
                            │
                            ▼
                   ┌────────────────┐
                   │  完整行程輸出  │
                   └────────────────┘
```

### 2.2 狀態流轉

系統使用 LangGraph 的 `AppState` 來管理整個規劃過程的狀態，包含以下關鍵欄位：

```python
class AppState(TypedDict):
    # 基本輸入
    user_input: str                          # 使用者原始輸入
    session_id: str                          # 對話 Session ID
    
    # 對話狀態
    conversation_state: ConversationState    # 對話狀態物件
    conversation_history: List[Dict]         # 對話歷史記錄
    collected_info: Dict                     # 已收集的資訊
    is_info_complete: bool                   # 資訊是否完整
    
    # 對話記憶
    conversation_memory: Dict                # 會話級別記憶
    context_summary: str                     # 上下文摘要
    previous_responses: List[str]            # 之前的 AI 回應
    turn_count: int                          # 對話輪次
    
    # 規劃資料
    story: Story                             # 使用者故事
    structured_candidates: List[Place]       # 結構化檢索結果
    semantic_candidates: List[Place]         # 語義檢索結果
    candidates: List[Place]                  # 融合後的候選景點
    accommodation_candidates: List           # 住宿候選清單
    itinerary: Itinerary                     # 最終行程
    
    # 錯誤與回應
    error: str                               # 錯誤訊息
    ai_response: str                         # AI 回應
    next_question: str                       # 下一個問題
```

---

## 3. 對話式規劃流程

### 3.1 對話記憶管理 (Conversation Memory Manager)

**節點職責**: 管理對話狀態、記憶與上下文

**執行流程**:

1. 獲取或創建對話狀態
   - 檢查 Redis 中是否存在 `session_id` 對應的對話狀態
   - 若不存在，創建新的 `ConversationState` 物件

2. 更新對話記錄
   - 增加對話輪次計數器
   - 將使用者訊息加入對話歷史
   - 更新上下文記憶

3. 生成上下文摘要
   - 從對話記憶中提取關鍵資訊
   - 生成簡潔的上下文摘要

4. 保存對話狀態
   - 將更新後的對話狀態序列化
   - 存入 Redis 供後續使用

**關鍵程式碼邏輯**:

```python
def conversation_memory_manager(self, state: AppState) -> AppState:
    session_id = state.get("session_id", "")
    user_input = state.get("user_input", "")
    
    # 獲取或創建對話狀態
    conversation_state = self._get_conversation_state(session_id)
    if not conversation_state:
        conversation_state = ConversationState(
            session_id, 
            ConversationStateType.COLLECTING_INFO
        )
    
    # 增加對話輪次
    conversation_state.increment_turn()
    
    # 添加用戶訊息到歷史
    conversation_state.add_message("user", user_input)
    
    # 更新上下文記憶
    conversation_state.add_context_memory(
        f"turn_{conversation_state.turn_count}_user", 
        user_input
    )
    
    # 分析用戶訊息並更新收集的資訊
    self._analyze_user_message_with_memory(conversation_state, user_input)
    
    # 檢查是否收集足夠資訊
    is_complete = self._is_info_complete(conversation_state)
    
    # 保存狀態
    self._save_conversation_state(conversation_state)
    
    return updated_state
```

### 3.2 資訊收集 (Info Collector)

**節點職責**: 透過多輪對話收集行程規劃所需的完整資訊

**必要資訊項目**:

| 資訊項目 | 欄位名稱 | 描述 | 範例 |
|---------|---------|------|------|
| 目的地 | `destination` | 旅遊目的地 | "宜蘭" |
| 旅遊天數 | `duration` | 行程天數 | "2天" |
| 興趣類型 | `interests` | 使用者興趣偏好 | ["美食", "自然景觀"] |
| 預算範圍 | `budget` | 預算等級 | "中等" |
| 旅遊風格 | `travel_style` | 旅遊節奏 | "悠閒" |
| 人數 | `group_size` | 旅遊人數 | "2人" |

**執行流程**:

1. 檢查資訊完整性
   - 遍歷必要資訊項目
   - 檢查 `collected_info` 中是否已收集

2. 生成智慧問題
   - 根據已收集資訊與對話歷史
   - 使用 LLM 生成自然、連貫的問題
   - 避免重複詢問已知資訊

3. 返回問題或繼續流程
   - 若資訊不完整，返回問題給使用者
   - 若資訊完整，進入下一階段

**資訊完整性檢查**:

```python
def _is_info_complete(self, state: ConversationState) -> bool:
    """檢查是否收集了所有必要資訊"""
    collected = state.collected_info
    
    # 必須有目的地和天數
    has_destination = "destination" in collected and collected["destination"]
    has_duration = "duration" in collected and collected["duration"]
    
    # 至少要有一項興趣或風格
    has_preference = (
        ("interests" in collected and collected["interests"]) or
        ("travel_style" in collected and collected["travel_style"])
    )
    
    return has_destination and has_duration and has_preference
```

---

## 4. 資訊收集與解析

### 4.1 使用者輸入分析

系統使用 Gemini LLM 來分析使用者的自然語言輸入，提取結構化資訊。

**分析邏輯**:

```python
def _analyze_user_message_with_memory(
    self, 
    state: ConversationState, 
    user_input: str
):
    """分析用戶訊息並更新收集的資訊"""
    
    prompt = f"""
    分析以下用戶訊息，提取旅遊相關資訊。
    
    已知資訊：
    {json.dumps(state.collected_info, ensure_ascii=False)}
    
    對話歷史：
    {self._format_conversation_history(state.conversation_history)}
    
    當前訊息：
    {user_input}
    
    請以 JSON 格式返回提取的資訊，包含以下欄位（若訊息中未提及則不包含該欄位）：
    - destination: 目的地
    - duration: 天數
    - interests: 興趣列表
    - budget: 預算
    - travel_style: 旅遊風格
    - group_size: 人數
    """
    
    # 調用 LLM 分析
    extracted_info = self.gemini_client.extract_info(prompt)
    
    # 更新收集的資訊
    for key, value in extracted_info.items():
        if value:
            state.collected_info[key] = value
```

### 4.2 Story 提取

當資訊收集完成後，系統會將收集到的資訊轉換為 `Story` 物件，這是整個規劃流程的核心資料結構。

**Story 資料結構**:

```python
@dataclass
class Story:
    days: int                          # 旅遊天數
    date_range: List[str]              # 日期範圍 ["2025-10-01", "2025-10-03"]
    daily_window: TimeWindow           # 每日時間窗
    preference: Preference             # 使用者偏好
    constraints: List[Constraint]      # 約束條件
```

**提取流程**:

```python
def extract_story(self, state: AppState) -> AppState:
    """從收集的資訊提取 Story"""
    
    collected_info = state.get("collected_info", {})
    
    # 構建規劃文字
    destination = collected_info.get("destination", "宜蘭")
    duration = collected_info.get("duration", "1天")
    interests = collected_info.get("interests", ["美食"])
    
    planning_text = f"我想要在{destination}進行{duration}的旅遊，包含{', '.join(interests)}"
    
    # 使用 LLM 提取 Story
    story = llm_client.extract_story_from_text(planning_text)
    
    return {**state, "story": story}
```

---

## 5. 地點檢索策略

系統採用**混合式檢索 (Hybrid Retrieval)** 策略，結合結構化查詢與語義搜尋，以提高檢索的準確性與覆蓋率。

### 5.1 結構化檢索 (Structured Retrieval)

**檢索目標**: 透過精確的 SQL 查詢，找出符合基本條件的景點

**查詢條件**:

1. **地理範圍**: 使用 PostGIS 的 `ST_DWithin` 函數進行半徑搜尋
2. **類別匹配**: 根據 `Story.preference.themes` 篩選類別
3. **評分過濾**: 過濾低評分景點
4. **營業狀態**: 排除永久關閉的景點

**SQL 查詢範例**:

```sql
SELECT 
    id, name, geom, categories, tags, 
    stay_minutes, price_range, rating
FROM places
WHERE 
    ST_DWithin(geom::geography, ST_SetSRID(ST_MakePoint(:lon, :lat), 4326)::geography, :radius)
    AND categories && :categories
    AND rating >= :min_rating
    AND status = 'open'
ORDER BY rating DESC, stay_minutes DESC
LIMIT 50;
```

**實作邏輯**:

```python
def retrieve_places_structured(self, state: AppState) -> AppState:
    """節點：結構化檢索地點"""
    story = state.get("story")
    
    db = SessionLocal()
    repo = PostgresPlaceRepository(db)
    
    # 執行結構化檢索
    structured_results = repo.search(
        categories=story.preference.themes,
        radius=50000,  # 50公里
        min_rating=3.0
    )
    
    db.close()
    
    return {**state, "structured_candidates": structured_results}
```

### 5.2 語義檢索 (Semantic Retrieval)

**檢索目標**: 透過語義相似度，找出與使用者偏好高度相關的景點

**執行流程**:

1. **生成查詢向量**
   - 將 `Story.preference` 轉換為自然語言描述
   - 使用 Embedding Model 生成查詢向量

2. **向量相似度搜尋**
   - 在向量資料庫中搜尋相似景點
   - 使用 Cosine Similarity 計算相似度

3. **結果過濾與排序**
   - 過濾相似度低於閾值的結果
   - 按相似度排序

**實作邏輯**:

```python
def retrieve_places_semantic(self, state: AppState) -> AppState:
    """節點：語義檢索地點"""
    story = state.get("story")
    
    # 生成查詢文本
    query_text = self._build_semantic_query(story)
    
    # 生成 Embedding
    query_vector = embedding_client.embed(query_text)
    
    # 向量搜尋
    semantic_results = vector_db.search(
        query_vector=query_vector,
        top_k=30,
        min_similarity=0.7
    )
    
    return {**state, "semantic_candidates": semantic_results}
```

### 5.3 結果融合與重排 (Rank and Merge)

**目標**: 將結構化與語義檢索的結果融合，並進行智慧重排序

**融合策略**:

1. **去重**: 合併兩路結果，移除重複景點
2. **動態評分**: 根據多個維度計算綜合分數
3. **多樣性控制**: 確保結果涵蓋不同類別與地理位置

**評分公式**:

```
Score = α × semantic_similarity 
      + β × rating 
      + γ × distance_score 
      + δ × popularity
      + ε × diversity_bonus
```

其中權重 `α, β, γ, δ, ε` 根據 `Story.preference.pace` 動態調整：

- **悠閒節奏**: 提高 `rating` 和 `semantic_similarity` 權重
- **緊湊節奏**: 提高 `distance_score` 權重，優先選擇地理位置集中的景點

**實作邏輯**:

```python
def rank_and_merge(self, state: AppState) -> AppState:
    """節點：排序與融合檢索結果"""
    structured = state.get("structured_candidates", [])
    semantic = state.get("semantic_candidates", [])
    story = state.get("story")
    
    # 合併並去重
    all_candidates = self._merge_candidates(structured, semantic)
    
    # 重排序
    ranked_candidates = rerank_service.rerank(
        candidates=all_candidates,
        story=story,
        weights=self._calculate_weights(story)
    )
    
    # 取前 N 個
    final_candidates = ranked_candidates[:20]
    
    return {**state, "candidates": final_candidates}
```

---

## 6. 評分與排序邏輯

### 6.1 重排序服務 (Rerank Service)

**核心職責**: 根據使用者偏好與多維度因素，對候選景點進行智慧排序

**評分維度**:

| 維度 | 權重變數 | 計算方式 | 說明 |
|-----|---------|---------|------|
| 語義相似度 | α | Cosine Similarity | 與使用者興趣的語義匹配度 |
| 景點評分 | β | Normalized Rating | 景點的使用者評分 (0-5) |
| 距離分數 | γ | exp(-distance/threshold) | 距離越近分數越高 |
| 熱門程度 | δ | Log(review_count + 1) | 評論數量的對數 |
| 多樣性獎勵 | ε | Category Diversity Bonus | 鼓勵類別多樣性 |

**權重動態調整**:

```python
def _calculate_weights(self, story: Story) -> Dict[str, float]:
    """根據 Story 動態計算權重"""
    weights = {
        "semantic": 0.3,
        "rating": 0.25,
        "distance": 0.2,
        "popularity": 0.15,
        "diversity": 0.1
    }
    
    # 根據旅遊節奏調整
    if story.preference.pace == "relaxed":
        weights["rating"] += 0.1
        weights["distance"] -= 0.1
    elif story.preference.pace == "packed":
        weights["distance"] += 0.15
        weights["semantic"] -= 0.05
        weights["rating"] -= 0.05
    
    return weights
```

### 6.2 多樣性控制

為避免推薦的景點過於單一，系統實作了多樣性控制機制：

1. **類別多樣性**: 確保涵蓋多種景點類別
2. **地理多樣性**: 避免所有景點集中在同一區域
3. **時間多樣性**: 確保不同時段都有適合的景點

```python
def _apply_diversity_bonus(
    self, 
    candidates: List[Place], 
    selected_categories: Set[str]
) -> List[Place]:
    """應用多樣性獎勵"""
    for place in candidates:
        # 檢查類別是否已被選中
        new_categories = set(place.categories) - selected_categories
        
        if new_categories:
            # 新類別獎勵
            place.diversity_bonus = len(new_categories) * 0.1
        else:
            place.diversity_bonus = 0
    
    return candidates
```

---

## 7. 核心規劃演算法

### 7.1 貪婪規劃器 (Greedy Planner)

**演算法概述**: 使用改進的貪婪演算法，快速生成符合約束的行程草案

**核心思路**:

1. 根據評分對候選點進行排序
2. 遍歷每一天
3. 在每一天中，從當前位置出發，選擇一個尚未訪問且「可行」的下一個地點
4. 重複直到當天時間滿了，或沒有可行的點了

**可行性定義**:

- **時間窗約束**: 加入該點後，不會超過當天的時間窗
- **營業時間**: 該點在預計到達時間是營業的
- **交通時間**: 從上一個景點到該景點的交通時間合理（< 60分鐘）
- **地理合理性**: 避免過度的地理跳躍

### 7.2 詳細實作流程

**步驟 1: 初始化**

```python
def plan(
    self, 
    story: Story, 
    candidates: List[Place], 
    travel_matrix: List[List[float]]
) -> Itinerary:
    """執行貪婪演算法來生成行程"""
    
    # 建立候選點 ID 到索引的映射
    place_id_to_idx = {str(p.id): i for i, p in enumerate(candidates)}
    
    # 獲取所有候選點的營業時間
    hours_map = repo.get_hours_for_places([str(p.id) for p in candidates])
    
    itinerary_days = []
    visited_place_ids = set()
    start_point_idx = 0  # 從第一個候選點作為起點
```

**步驟 2: 逐日規劃**

```python
for day_num in range(story.days):
    # 獲取當日日期和時間窗
    current_day = story.date_range[0] + timedelta(days=day_num)
    
    daily_visits = []
    
    # 從 Story 中獲取時間窗
    day_start_time = parse_time_to_minutes(story.daily_window.start)  # 例如 9:00 -> 540
    day_end_time = parse_time_to_minutes(story.daily_window.end)      # 例如 18:00 -> 1080
    
    current_time = day_start_time
    last_place_idx = start_point_idx
    
    # 允許稍微超過結束時間（90分鐘緩衝）
    while current_time < day_end_time + 90:
        next_visit = self._find_next_best_visit(
            candidates,
            travel_matrix,
            place_id_to_idx,
            visited_place_ids,
            last_place_idx,
            current_time,
            day_end_time,
            hours_map,
            current_day.weekday()
        )
        
        if not next_visit:
            break  # 沒有可行的景點了
        
        place, travel_minutes = next_visit
        
        # 計算到達與離開時間
        eta_minutes = current_time + travel_minutes
        etd_minutes = eta_minutes + place.stay_minutes
        
        # 創建訪問記錄
        visit = Visit(
            place_id=str(place.id),
            name=place.name,
            eta=minutes_to_time_str(eta_minutes),  # 540 -> "09:00"
            etd=minutes_to_time_str(etd_minutes),  # 660 -> "11:00"
            travel_minutes=travel_minutes
        )
        
        daily_visits.append(visit)
        visited_place_ids.add(str(place.id))
        current_time = etd_minutes
        last_place_idx = place_id_to_idx[str(place.id)]
```

**步驟 3: 選擇下一個最佳訪問點**

```python
def _find_next_best_visit(
    self,
    candidates: List[Place],
    travel_matrix: List[List[float]],
    place_id_to_idx: Dict[str, int],
    visited_place_ids: set,
    from_place_idx: int,
    current_time: int,
    day_end_time: int,
    hours_map: Dict[str, List[Any]],
    weekday: int
) -> Optional[Tuple[Place, int]]:
    """從當前位置找到下一個最佳的、可行的訪問點"""
    
    best_visit = None
    best_score = -1
    
    for i, place in enumerate(candidates):
        # 跳過已訪問的景點
        if str(place.id) in visited_place_ids:
            continue
        
        # 計算交通時間
        travel_seconds = travel_matrix[from_place_idx][i]
        travel_minutes = round(travel_seconds / 60)
        
        # 避免過度的地理跳躍（交通時間 > 60 分鐘）
        if travel_minutes > 60:
            continue
        
        # 計算到達與離開時間
        eta = current_time + travel_minutes
        etd = eta + place.stay_minutes
        
        # 可行性檢查
        max_allowed_end = day_end_time + 90  # 允許 90 分鐘緩衝
        
        if etd <= max_allowed_end and self._is_open(str(place.id), eta, weekday, hours_map):
            # 計算時間利用分數
            time_remaining = day_end_time - current_time
            time_utilization_score = (etd - day_end_time) / 60.0
            
            # 如果景點能在正常時間內完成，給予額外分數
            if etd <= day_end_time:
                time_utilization_score += 10
            
            # 如果景點能充分利用剩餘時間（>= 80%），給予額外分數
            if place.stay_minutes >= time_remaining * 0.8:
                time_utilization_score += 5
            
            # 選擇分數最高的景點
            if time_utilization_score > best_score:
                best_score = time_utilization_score
                best_visit = (place, travel_minutes)
    
    return best_visit
```

**步驟 4: 營業時間檢查**

```python
def _is_open(
    self, 
    place_id: str, 
    arrival_minute: int, 
    weekday: int, 
    hours_map: Dict[str, List[Any]]
) -> bool:
    """檢查地點在指定時間是否營業"""
    
    place_hours = hours_map.get(place_id, [])
    
    # 沒有營業時間資訊，假設全天開放
    if not place_hours:
        return True
    
    # 將 Python 的 weekday (Monday=0) 轉換為資料庫的 weekday (Sunday=0)
    db_weekday = (weekday + 1) % 7
    
    for hour_range in place_hours:
        if hour_range.weekday == db_weekday:
            if hour_range.open_min <= arrival_minute <= hour_range.close_min:
                return True
    
    return False
```

### 7.3 時間窗管理

系統精確管理每日的時間窗，確保行程符合使用者的作息習慣。

**時間表示方式**:

- **內部表示**: 從午夜開始的分鐘數 (0-1439)
  - 例如: 09:00 → 540 分鐘, 18:00 → 1080 分鐘

- **外部表示**: HH:MM 格式
  - 例如: "09:00", "18:00"

**時間轉換函數**:

```python
def _parse_time_to_minutes(self, time_str: str) -> int:
    """將 HH:MM 格式轉換為分鐘數"""
    hour, minute = map(int, time_str.split(':'))
    return hour * 60 + minute

def _minutes_to_time_str(self, minutes: int) -> str:
    """將分鐘數轉換為 HH:MM 格式"""
    hour = minutes // 60
    minute = minutes % 60
    return f"{hour:02d}:{minute:02d}"
```

---

## 8. 路徑優化機制

### 8.1 2-opt 演算法

**目標**: 對已生成的行程進行局部優化，減少總交通時間

**演算法原理**:

2-opt 是一種經典的路徑優化演算法，透過交換路徑中的兩條邊來減少總距離。

**視覺化範例**:

```
原始路徑: A → B → C → D → E

嘗試交換 B-C 和 D-E 之間的路徑:
優化後: A → B → D → C → E

如果優化後的路徑總距離更短，則採用新路徑。
```

**實作邏輯**:

```python
def _refine_with_2_opt(
    self,
    day_plan: Day,
    candidates: List[Place],
    travel_matrix: List[List[float]],
    place_id_to_idx: Dict[str, int]
):
    """使用 2-opt 演算法對一天的行程進行局部優化"""
    
    # 至少需要 4 個景點才有意義優化
    if len(day_plan.visits) < 4:
        return
    
    improved = True
    
    while improved:
        improved = False
        
        for i in range(1, len(day_plan.visits) - 2):
            for j in range(i + 1, len(day_plan.visits)):
                # 獲取四個景點的索引
                p1_idx = place_id_to_idx[day_plan.visits[i-1].place_id]
                p2_idx = place_id_to_idx[day_plan.visits[i].place_id]
                p3_idx = place_id_to_idx[day_plan.visits[j-1].place_id]
                p4_idx = place_id_to_idx[day_plan.visits[j].place_id]
                
                # 計算原始距離與新距離
                original_dist = (
                    travel_matrix[p1_idx][p2_idx] + 
                    travel_matrix[p3_idx][p4_idx]
                )
                new_dist = (
                    travel_matrix[p1_idx][p3_idx] + 
                    travel_matrix[p2_idx][p4_idx]
                )
                
                # 如果新路徑更短
                if new_dist < original_dist:
                    # 防止過度的地理跳躍
                    distance_improvement = original_dist - new_dist
                    if distance_improvement > 1800:  # 超過 30 分鐘
                        continue
                    
                    # 交換路線
                    day_plan.visits[i:j] = day_plan.visits[j-1:i-1:-1]
                    
                    # 重新計算時間
                    self._recalculate_times(
                        day_plan, 
                        candidates, 
                        travel_matrix, 
                        place_id_to_idx
                    )
                    
                    improved = True
```

### 8.2 時間重新計算

當路徑順序改變後，需要重新計算所有景點的到達與離開時間。

```python
def _recalculate_times(
    self, 
    day_plan: Day, 
    candidates: List[Place], 
    travel_matrix: List[List[float]], 
    place_id_to_idx: Dict[str, int]
):
    """重新計算行程的時間安排"""
    
    if not day_plan.visits:
        return
    
    # 創建候選點 ID 到 Place 物件的映射
    place_id_to_place = {str(p.id): p for p in candidates}
    
    # 從第一個景點開始重新計算時間
    current_time = self._parse_time_to_minutes(day_plan.visits[0].eta)
    
    for i, visit in enumerate(day_plan.visits):
        place = place_id_to_place.get(visit.place_id)
        
        # 計算到達時間
        eta_minutes = current_time
        visit.eta = self._minutes_to_time_str(eta_minutes)
        
        # 計算離開時間
        etd_minutes = eta_minutes + place.stay_minutes
        visit.etd = self._minutes_to_time_str(etd_minutes)
        
        # 計算到下一個景點的交通時間
        if i < len(day_plan.visits) - 1:
            current_idx = place_id_to_idx[visit.place_id]
            next_idx = place_id_to_idx[day_plan.visits[i + 1].place_id]
            travel_seconds = travel_matrix[current_idx][next_idx]
            travel_minutes = round(travel_seconds / 60)
            visit.travel_minutes = travel_minutes
            current_time = etd_minutes + travel_minutes
        else:
            visit.travel_minutes = 0
```

### 8.3 優化效果評估

系統在應用 2-opt 優化後，會記錄優化前後的總交通時間，以評估優化效果。

**效果指標**:

- **總交通時間減少率**: (原始時間 - 優化後時間) / 原始時間 × 100%
- **平均單次交通時間**: 總交通時間 / 景點數
- **最長交通時間**: 單次最長的交通時間

---

## 9. 住宿推薦邏輯

### 9.1 住宿檢索策略

**目標**: 為每日行程推薦合適的住宿地點

**檢索流程**:

1. **確定搜尋中心**
   - 使用當日最後一個景點的位置作為搜尋中心
   - 若當日無景點，使用目的地中心

2. **半徑搜尋**
   - 在搜尋中心周圍 5-10 公里範圍內搜尋住宿
   - 使用 PostGIS 的地理空間查詢

3. **條件過濾**
   - 評分 >= 4.0
   - 價格符合預算範圍
   - 有空房（若有即時資料）

4. **排序與選擇**
   - 優先選擇評分高、距離近的住宿
   - 考慮使用者的預算偏好

**實作邏輯**:

```python
def retrieve_accommodations(self, state: AppState) -> AppState:
    """節點：檢索住宿"""
    
    story = state.get("story")
    itinerary = state.get("itinerary")
    
    if not itinerary or not itinerary.days:
        return state
    
    db = SessionLocal()
    repo = PostgresAccommodationRepository(db)
    
    accommodation_candidates = []
    
    for day in itinerary.days:
        if not day.visits:
            continue
        
        # 使用最後一個景點的位置
        last_visit = day.visits[-1]
        last_place = self._get_place_by_id(last_visit.place_id)
        
        # 在周圍搜尋住宿
        accommodations = repo.search_nearby(
            lat=last_place.latitude,
            lon=last_place.longitude,
            radius=10000,  # 10 公里
            min_rating=4.0,
            budget=story.preference.budget
        )
        
        accommodation_candidates.append(accommodations[:5])
    
    db.close()
    
    return {**state, "accommodation_candidates": accommodation_candidates}
```

### 9.2 住宿推薦服務

**智慧推薦因素**:

1. **地理位置**: 距離當日最後景點的距離
2. **評分與評論**: 使用者評分與評論數量
3. **價格匹配**: 符合使用者預算
4. **設施偏好**: 根據使用者偏好（如停車場、早餐、WiFi）

**推薦邏輯**:

```python
def _get_accommodation_for_day(self, day_num: int, story: Story) -> Accommodation:
    """為指定天數推薦住宿"""
    
    # 從候選清單中選擇最佳住宿
    candidates = accommodation_recommendation_service.get_recommendations(
        day_num=day_num,
        story=story,
        last_place_location=last_place_location
    )
    
    if not candidates:
        return None
    
    # 選擇評分最高的住宿
    best_accommodation = candidates[0]
    
    return Accommodation(
        name=best_accommodation.name,
        address=best_accommodation.address,
        rating=best_accommodation.rating,
        price=best_accommodation.price,
        amenities=best_accommodation.amenities
    )
```

---

## 10. 使用者回饋處理

### 10.1 回饋 DSL (Domain-Specific Language)

系統定義了一套簡單的 DSL 來表示使用者的修改需求。

**支援的操作**:

| 操作 | DSL 格式 | 說明 | 範例 |
|-----|---------|------|------|
| 刪除景點 | `DROP` | 從行程中移除指定景點 | "我不想去第 2 天的第 1 個景點" |
| 替換景點 | `REPLACE` | 用另一個景點替換現有景點 | "把第 1 天的餐廳換成火鍋店" |
| 移動景點 | `MOVE` | 將景點移動到不同時間或順序 | "把景點 A 移到第 2 天" |
| 新增景點 | `ADD` | 在行程中新增景點 | "我想加入某某博物館" |

**DSL 結構**:

```json
{
  "op": "DROP | REPLACE | MOVE | ADD",
  "target": {
    "day": 1,
    "visit_index": 0,
    "place_id": "uuid"
  },
  "replacement": {
    "place_id": "uuid",
    "place_name": "新景點名稱"
  },
  "reason": "使用者的理由"
}
```

### 10.2 回饋解析

**解析流程**:

1. **使用者輸入**: "我不想去第 2 天的餐廳，太貴了"

2. **LLM 解析**: 將自然語言轉換為 DSL

```python
def parse_feedback_to_dsl(self, feedback_text: str, itinerary: Itinerary) -> Dict:
    """將自然語言回饋解析為 DSL"""
    
    prompt = f"""
    解析以下使用者回饋，將其轉換為修改指令。
    
    行程內容：
    {json.dumps(itinerary.to_dict(), ensure_ascii=False)}
    
    使用者回饋：
    {feedback_text}
    
    請以 JSON 格式返回，包含以下欄位：
    - op: 操作類型 (DROP, REPLACE, MOVE, ADD)
    - target: 目標對象 (包含 day, visit_index, place_id)
    - replacement: 替換對象 (若為 REPLACE 操作)
    - reason: 使用者理由
    """
    
    dsl = llm_client.parse_to_json(prompt)
    return dsl
```

3. **DSL 輸出**:

```json
{
  "op": "DROP",
  "target": {
    "day": 2,
    "visit_index": 2,
    "place_id": "restaurant-123"
  },
  "reason": "太貴了"
}
```

### 10.3 回饋執行

**執行邏輯**:

```python
def handle_feedback(self, itinerary: Itinerary, dsl: Dict[str, Any]) -> Itinerary:
    """根據 DSL 指令修改行程"""
    
    op = dsl.get("op")
    target = dsl.get("target", {})
    
    if op == "DROP":
        # 刪除指定景點
        day_index = target.get("day") - 1
        visit_index = target.get("visit_index")
        
        if 0 <= day_index < len(itinerary.days):
            day = itinerary.days[day_index]
            if 0 <= visit_index < len(day.visits):
                removed_visit = day.visits.pop(visit_index)
                
                # 重新計算後續景點的時間
                self._recalculate_day_times(day)
                
    elif op == "REPLACE":
        # 替換指定景點
        day_index = target.get("day") - 1
        visit_index = target.get("visit_index")
        replacement = dsl.get("replacement", {})
        new_place_id = replacement.get("place_id")
        
        # 獲取新景點資訊
        new_place = self._get_place_by_id(new_place_id)
        
        # 替換並重新計算時間
        if 0 <= day_index < len(itinerary.days):
            day = itinerary.days[day_index]
            if 0 <= visit_index < len(day.visits):
                day.visits[visit_index] = self._create_visit_from_place(new_place)
                self._recalculate_day_times(day)
    
    elif op == "MOVE":
        # 移動景點到其他天或順序
        # ... (實作邏輯)
        pass
    
    elif op == "ADD":
        # 新增景點
        # ... (實作邏輯)
        pass
    
    return itinerary
```

### 10.4 回饋 API 端點

```python
@router.post("/feedback")
async def process_feedback(request: FeedbackRequest):
    """處理使用者回饋並更新行程"""
    
    # 解析回饋為 DSL
    dsl = feedback_parser.parse_feedback_to_dsl(
        request.feedback_text,
        request.itinerary
    )
    
    # 執行修改
    updated_itinerary = greedy_planner.handle_feedback(
        request.itinerary,
        dsl
    )
    
    # 記錄回饋事件
    db = SessionLocal()
    db.execute(
        "INSERT INTO feedback_event (session_id, op, reason) VALUES (:sid, :op, :reason)",
        {"sid": request.session_id, "op": dsl["op"], "reason": dsl["reason"]}
    )
    db.commit()
    db.close()
    
    return updated_itinerary
```

---

## 11. 錯誤處理與容錯

### 11.1 常見錯誤情境

| 錯誤類型 | 情境描述 | 處理策略 |
|---------|---------|---------|
| **資訊不足** | 使用者未提供足夠資訊 | 繼續對話收集資訊 |
| **無可行景點** | 在給定約束下找不到景點 | 放寬半徑或類別約束 |
| **時間窗不足** | 無法在時間窗內安排景點 | 減少景點數量或延長時間窗 |
| **交通時間過長** | 景點間距離過遠 | 移除遠距離景點或分組規劃 |
| **LLM 解析失敗** | LLM 返回格式錯誤 | 使用備用解析邏輯或預設值 |
| **OSRM 服務異常** | OSRM 無法計算路徑 | 使用直線距離估算或快取資料 |

### 11.2 分層容錯策略

**第一層: 輸入驗證**

```python
def validate_user_input(user_input: str) -> bool:
    """驗證使用者輸入是否有效"""
    if not user_input or len(user_input) < 2:
        return False
    if len(user_input) > 1000:
        return False
    return True
```

**第二層: 資料完整性檢查**

```python
def validate_story(story: Story) -> Tuple[bool, str]:
    """驗證 Story 物件的完整性"""
    if story.days <= 0:
        return False, "天數必須大於 0"
    if not story.daily_window:
        return False, "缺少時間窗資訊"
    if not story.preference.themes:
        return False, "缺少興趣主題"
    return True, ""
```

**第三層: 服務降級**

```python
async def get_travel_matrix_with_fallback(
    candidates: List[Place]
) -> List[List[float]]:
    """獲取交通時間矩陣，失敗時使用降級策略"""
    try:
        # 嘗試調用 OSRM
        matrix = await osrm_client.get_travel_matrix(candidates)
        return matrix
    except OSRMException:
        # 降級為直線距離估算
        logger.warning("OSRM service failed, using haversine distance")
        return calculate_haversine_matrix(candidates)
```

**第四層: 優雅失敗**

```python
def plan_itinerary_safe(
    state: AppState
) -> AppState:
    """安全的行程規劃，確保不會完全失敗"""
    try:
        itinerary = greedy_planner.plan(
            story=state["story"],
            candidates=state["candidates"],
            travel_matrix=state["travel_matrix"]
        )
        return {**state, "itinerary": itinerary}
    except Exception as e:
        logger.error(f"Planning failed: {e}")
        
        # 返回最小可行行程
        minimal_itinerary = create_minimal_itinerary(state["story"])
        
        return {
            **state, 
            "itinerary": minimal_itinerary,
            "error": "行程規劃遇到問題，已提供簡化版本"
        }
```

### 11.3 日誌與監控

系統在關鍵節點記錄日誌，便於除錯與監控。

```python
import logging

logger = logging.getLogger(__name__)

def plan_itinerary(self, state: AppState) -> AppState:
    """節點：行程規劃"""
    logger.info(f"開始行程規劃，session_id={state['session_id']}")
    
    try:
        # ... 規劃邏輯 ...
        logger.info(f"行程規劃成功，生成了 {len(itinerary.days)} 天行程")
    except Exception as e:
        logger.error(f"行程規劃失敗: {e}", exc_info=True)
        raise
```

---

## 12. 效能優化策略

### 12.1 快取機制

**Redis 快取架構**:

```python
class OSRMClientWithCache:
    """帶快取的 OSRM 客戶端"""
    
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.cache_ttl = 86400  # 24 小時
    
    async def get_travel_matrix(
        self, 
        candidates: List[Place]
    ) -> List[List[float]]:
        """獲取交通時間矩陣，優先使用快取"""
        
        # 生成快取鍵
        cache_key = self._generate_cache_key(candidates)
        
        # 嘗試從快取讀取
        cached_matrix = self.redis_client.get(cache_key)
        if cached_matrix:
            logger.info("使用快取的交通時間矩陣")
            return json.loads(cached_matrix)
        
        # 快取未命中，調用 OSRM
        matrix = await self._call_osrm_api(candidates)
        
        # 寫入快取
        self.redis_client.setex(
            cache_key, 
            self.cache_ttl, 
            json.dumps(matrix)
        )
        
        return matrix
```

**快取鍵設計**:

```python
def _generate_cache_key(self, candidates: List[Place]) -> str:
    """生成快取鍵"""
    # 使用景點 ID 的排序雜湊作為鍵
    place_ids = sorted([str(p.id) for p in candidates])
    key_string = "_".join(place_ids)
    cache_key = f"osrm:matrix:{hashlib.md5(key_string.encode()).hexdigest()}"
    return cache_key
```

### 12.2 並行處理

**並行檢索**:

```python
async def retrieve_candidates_parallel(self, state: AppState) -> AppState:
    """並行執行結構化與語義檢索"""
    
    story = state.get("story")
    
    # 並行執行兩種檢索
    structured_task = asyncio.create_task(
        self._retrieve_structured_async(story)
    )
    semantic_task = asyncio.create_task(
        self._retrieve_semantic_async(story)
    )
    
    # 等待兩個任務完成
    structured_results, semantic_results = await asyncio.gather(
        structured_task,
        semantic_task
    )
    
    return {
        **state,
        "structured_candidates": structured_results,
        "semantic_candidates": semantic_results
    }
```

### 12.3 資料庫優化

**索引策略**:

```sql
-- 地理空間索引
CREATE INDEX places_geom_idx ON places USING GIST (geom);

-- 類別索引
CREATE INDEX places_categories_idx ON places USING GIN (categories);

-- 複合索引
CREATE INDEX places_rating_idx ON places (rating DESC);

-- 營業時間索引
CREATE INDEX hours_lookup_idx ON hours (place_id, weekday);
```

**查詢優化**:

```sql
-- 優化前：分別查詢
SELECT * FROM places WHERE id IN (...);
SELECT * FROM hours WHERE place_id IN (...);

-- 優化後：JOIN 查詢
SELECT 
    p.*, 
    json_agg(h.*) as hours
FROM places p
LEFT JOIN hours h ON p.id = h.place_id
WHERE p.id IN (...)
GROUP BY p.id;
```

### 12.4 批次處理

**批次獲取營業時間**:

```python
def get_hours_for_places(
    self, 
    place_ids: List[str]
) -> Dict[str, List[HourRange]]:
    """批次獲取多個景點的營業時間"""
    
    if not place_ids:
        return {}
    
    # 單次查詢獲取所有營業時間
    query = """
        SELECT place_id, weekday, open_min, close_min
        FROM hours
        WHERE place_id = ANY(:place_ids)
        ORDER BY place_id, weekday, open_min
    """
    
    results = self.db.execute(
        text(query),
        {"place_ids": place_ids}
    ).fetchall()
    
    # 組織為字典
    hours_map = defaultdict(list)
    for row in results:
        hours_map[row.place_id].append(
            HourRange(
                weekday=row.weekday,
                open_min=row.open_min,
                close_min=row.close_min
            )
        )
    
    return dict(hours_map)
```

### 12.5 效能監控

**關鍵指標**:

| 指標 | 目標值 | 監控方式 |
|-----|-------|---------|
| API 回應時間 | < 3 秒 | APM 工具 |
| LLM 調用延遲 | < 1 秒 | 日誌分析 |
| OSRM 矩陣計算 | < 500ms | 時間戳記錄 |
| 快取命中率 | > 70% | Redis 統計 |
| 資料庫查詢 | < 100ms | 慢查詢日誌 |

**監控程式碼**:

```python
import time
from functools import wraps

def monitor_performance(operation_name: str):
    """效能監控裝飾器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                elapsed = time.time() - start_time
                logger.info(f"{operation_name} 耗時: {elapsed:.3f}秒")
                return result
            except Exception as e:
                elapsed = time.time() - start_time
                logger.error(f"{operation_name} 失敗，耗時: {elapsed:.3f}秒，錯誤: {e}")
                raise
        return wrapper
    return decorator

@monitor_performance("行程規劃")
async def plan_itinerary(self, state: AppState) -> AppState:
    # ... 實作邏輯 ...
    pass
```

---

## 附錄 A: 關鍵資料結構

### A.1 Story

```python
@dataclass
class Story:
    days: int
    date_range: List[str]
    daily_window: TimeWindow
    preference: Preference
    constraints: List[Constraint]
```

### A.2 Place

```python
@dataclass
class Place:
    id: str
    name: str
    latitude: float
    longitude: float
    categories: List[str]
    tags: List[str]
    stay_minutes: int
    price_range: int
    rating: float
```

### A.3 Itinerary

```python
@dataclass
class Itinerary:
    days: List[Day]

@dataclass
class Day:
    date: str
    visits: List[Visit]
    accommodation: Optional[Accommodation]

@dataclass
class Visit:
    place_id: str
    name: str
    eta: str  # HH:MM
    etd: str  # HH:MM
    travel_minutes: int
```

---

## 附錄 B: API 端點總覽

| 端點 | 方法 | 功能 | 輸入 | 輸出 |
|-----|------|------|------|------|
| `/v1/itinerary/propose` | POST | 生成行程草案 | `ProposeRequest` | `Itinerary` 或對話回應 |
| `/v1/itinerary/feedback` | POST | 處理使用者回饋 | `FeedbackRequest` | 更新後的 `Itinerary` |
| `/v1/places/search` | GET | 搜尋地點 | Query 參數 | `List[Place]` |

---

## 附錄 C: 環境變數配置

```bash
# 資料庫
DATABASE_URL=postgresql://user:password@localhost:5432/itinerary_db

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# OSRM
OSRM_HOST=http://localhost:5000

# LLM API
OPENAI_API_KEY=your-api-key
GEMINI_API_KEY=your-gemini-key

# 向量資料庫
MILVUS_HOST=localhost
MILVUS_PORT=19530
```

---

**文件結束**

本文件詳細描述了智慧旅遊行程規劃系統的完整規劃邏輯，涵蓋從使用者輸入到最終行程生成的所有環節。系統採用模組化設計，確保每個組件職責清晰、易於維護與擴展。
